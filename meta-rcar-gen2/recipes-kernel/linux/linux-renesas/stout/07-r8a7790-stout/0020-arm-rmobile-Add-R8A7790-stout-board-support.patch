From 7de9e2457015029030fd15368e000f7115a81e0f Mon Sep 17 00:00:00 2001
From: Vladimir Barinov <vladimir.barinov@cogentembedded.com>
Date: Fri, 15 May 2015 19:25:14 +0300
Subject: [PATCH] arm: rmobile: Add R8A7790-stout board support

R8A7790-stout is an entry level development board based on R-Car H2 SoC (R8A7790)

Signed-off-by: Vladimir Barinov <vladimir.barinov@cogentembedded.com>
---
 arch/arm/boot/dts/Makefile                         |   1 +
 arch/arm/boot/dts/r8a7790-stout.dts                | 643 ++++++++++++++++++
 arch/arm/configs/shmobile_defconfig                |   1 +
 arch/arm/mach-shmobile/Kconfig                     |   5 +
 arch/arm/mach-shmobile/Makefile                    |   1 +
 .../mach-shmobile/board-r8a7790stout-reference.c   | 731 +++++++++++++++++++++
 drivers/pinctrl/Kconfig                            |   3 +
 drivers/pinctrl/Makefile                           |   1 +
 drivers/pinctrl/pinmux-ext.c                       | 299 +++++++++
 drivers/pinctrl/pinmux-ext.h                       | 192 ++++++
 10 files changed, 1877 insertions(+)
 create mode 100644 arch/arm/boot/dts/r8a7790-stout.dts
 create mode 100644 arch/arm/mach-shmobile/board-r8a7790stout-reference.c
 create mode 100644 drivers/pinctrl/pinmux-ext.c
 create mode 100644 drivers/pinctrl/pinmux-ext.h

diff --git a/arch/arm/boot/dts/Makefile b/arch/arm/boot/dts/Makefile
index a1de751..5482be6 100644
--- a/arch/arm/boot/dts/Makefile
+++ b/arch/arm/boot/dts/Makefile
@@ -178,6 +178,7 @@ dtb-$(CONFIG_ARCH_SHMOBILE_MULTI) += emev2-kzm9d.dtb \
 	r8a7791-koelsch.dtb \
 	r8a7791-porter.dtb \
 	r8a7790-lager.dtb \
+	r8a7790-stout.dtb \
 	r8a7794-alt.dtb \
 	r8a7794-silk.dtb \
 	r8a7793-gose.dtb \
diff --git a/arch/arm/boot/dts/r8a7790-stout.dts b/arch/arm/boot/dts/r8a7790-stout.dts
new file mode 100644
index 0000000..a4c70de
--- /dev/null
+++ b/arch/arm/boot/dts/r8a7790-stout.dts
@@ -0,0 +1,643 @@
+/*
+ * Device Tree Source for the R8A7790-stout board
+ *
+ * Copyright (C) 2015 Renesas Electronics Europe GmbH
+ * Copyright (C) 2015 Renesas Electronics Corporation
+ * Copyright (C) 2015 Cogent Embedded, Inc.
+ *
+ * This file is licensed under the terms of the GNU General Public License
+ * version 2.  This program is licensed "as is" without any warranty of any
+ * kind, whether express or implied.
+ */
+
+/dts-v1/;
+#include "r8a7790.dtsi"
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/input/input.h>
+
+/ {
+	model = "R8A7790-stout";
+	compatible = "renesas,r8a7790stout", "renesas,r8a7790";
+
+	aliases {
+		serial0 = &scifa0;
+		serial1 = &scifa1;
+		serial2 = &scifa2;
+		serial9 = &hscif1;
+	};
+
+	chosen {
+		bootargs = "console=ttySC0,38400 ignore_loglevel rw root=/dev/nfs ip=dhcp vmalloc=384M";
+	};
+
+	memory@40000000 {
+		device_type = "memory";
+		reg = <0 0x40000000 0 0x40000000>;
+	};
+
+	memory@200000000 {
+		device_type = "memory";
+		reg = <2 0x00000000 0 0x40000000>;
+	};
+
+	lbsc {
+		#address-cells = <1>;
+		#size-cells = <1>;
+	};
+
+	gpio-keys {
+		compatible = "gpio-keys";
+
+		button@1 {
+			linux,code = <KEY_1>;
+			label = "SW3-1";
+			gpio-key,wakeup;
+			debounce-interval = <20>;
+			gpios = <&gpio1 0 GPIO_ACTIVE_HIGH>;
+		};
+		button@2 {
+			linux,code = <KEY_2>;
+			label = "SW3-2";
+			gpio-key,wakeup;
+			debounce-interval = <20>;
+			gpios = <&gpio1 1 GPIO_ACTIVE_HIGH>;
+		};
+		button@3 {
+			linux,code = <KEY_3>;
+			label = "SW3-3";
+			gpio-key,wakeup;
+			debounce-interval = <20>;
+			gpios = <&gpio1 2 GPIO_ACTIVE_HIGH>;
+		};
+		button@4 {
+			linux,code = <KEY_4>;
+			label = "SW3-4";
+			gpio-key,wakeup;
+			debounce-interval = <20>;
+			gpios = <&gpio1 3 GPIO_ACTIVE_HIGH>;
+		};
+		button@5 {
+			linux,code = <KEY_5>;
+			label = "SW3-5";
+			gpio-key,wakeup;
+			debounce-interval = <20>;
+			gpios = <&gpio0 18 GPIO_ACTIVE_HIGH>;
+		};
+		button@6 {
+			linux,code = <KEY_6>;
+			label = "SW3-6";
+			gpio-key,wakeup;
+			debounce-interval = <20>;
+			gpios = <&gpio0 19 GPIO_ACTIVE_HIGH>;
+		};
+		button@7 {
+			linux,code = <KEY_7>;
+			label = "SW3-7";
+			gpio-key,wakeup;
+			debounce-interval = <20>;
+			gpios = <&gpio0 20 GPIO_ACTIVE_HIGH>;
+		};
+		button@8 {
+			linux,code = <KEY_8>;
+			label = "SW3-8";
+			gpio-key,wakeup;
+			debounce-interval = <20>;
+			gpios = <&gpio0 22 GPIO_ACTIVE_HIGH>;
+		};
+	};
+
+	leds {
+		compatible = "gpio-leds";
+		led1 {
+			gpios = <&gpio4 22 GPIO_ACTIVE_LOW>;
+		};
+		led2 {
+			gpios = <&gpio4 23 GPIO_ACTIVE_LOW>;
+		};
+		led3 {
+			gpios = <&gpio5 17 GPIO_ACTIVE_LOW>;
+		};
+		led5 {
+			gpios = <&gpio4 24 GPIO_ACTIVE_LOW>;
+		};
+	};
+
+	vcc_sdhi0: regulator@1 {
+		compatible = "regulator-fixed";
+
+		regulator-name = "SDHI0 Vcc";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+
+		gpio = <&gpio5 24 GPIO_ACTIVE_HIGH>;
+		enable-active-high;
+	};
+
+	vccq_sdhi0: regulator@2 {
+		compatible = "regulator-fixed";
+
+		regulator-name = "SDHI0 VccQ";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+
+		gpio = <&gpio3 30 GPIO_ACTIVE_HIGH>;
+		enable-active-high;
+	};
+
+	vcc_sdhi2: regulator@3 {
+		compatible = "regulator-fixed";
+
+		regulator-name = "SDHI2 Vcc";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+
+		gpio = <&gpio5 25 GPIO_ACTIVE_HIGH>;
+		enable-active-high;
+	};
+
+	vccq_sdhi2: regulator@4 {
+		compatible = "regulator-fixed";
+
+		regulator-name = "SDHI2 VccQ";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+
+		gpio = <&gpio3 29 GPIO_ACTIVE_HIGH>;
+		enable-active-high;
+	};
+
+	hdmi_transmitter: adv7511 {
+		compatible = "adi,adv7511";
+		gpios = <&gpio1 23 GPIO_ACTIVE_LOW>;
+
+		adi,reg = <0x39>;
+		adi,input-style = <0x02>;
+		adi,input-id = <0x00>;
+		adi,input-color-depth = <0x03>;
+		adi,sync-pulse = <0x03>;
+		adi,bit-justification = <0x01>;
+		adi,up-conversion = <0x00>;
+		adi,timing-generation-sequence = <0x00>;
+		adi,vsync-polarity = <0x02>;
+		adi,hsync-polarity = <0x02>;
+		adi,clock-delay = <0x03>;
+	};
+
+	cpld_mux {
+		compatible = "pinmux-ext";
+
+/*
+		pinctrl-names = "state0";
+		pinctrl-0 = <&state_0>;
+*/
+
+		pinmux-ext,sclk-gpio = <&gpio3 24 GPIO_ACTIVE_HIGH>;
+		pinmux-ext,sstbz-gpio = <&gpio3 25 GPIO_ACTIVE_HIGH>;
+		pinmux-ext,mosi-gpio = <&gpio3 26 GPIO_ACTIVE_HIGH>;
+		pinmux-ext,miso-gpio = <&gpio3 27 GPIO_ACTIVE_HIGH>;
+	};
+};
+
+&extal_clk {
+	clock-frequency = <20000000>;
+};
+
+&pfc {
+	pinctrl-0 = <&du_pins &du0_pins &usb0_pins &usb1_pins &usb2_pins>;
+	pinctrl-names = "default";
+
+	du_pins: du {
+		renesas,groups = "du_rgb888", "du_sync_1", "du_clk_out_0";
+		renesas,function = "du";
+	};
+
+	du0_pins: du0 {
+		renesas,groups = "du0_clk_in";
+		renesas,function = "du0";
+	};
+
+	scifa0_pins: serial0 {
+		renesas,groups = "scifa0_data_b", "scifa0_clk_b";
+		renesas,function = "scifa0";
+	};
+
+	scifa1_pins: serial1 {
+		renesas,groups = "scifa1_data_b", "scifa1_clk_b";
+		renesas,function = "scifa1";
+	};
+
+	scifa2_pins: serial2 {
+		renesas,groups = "scifa2_data_c", "scifa2_clk_c";
+		renesas,function = "scifa2";
+	};
+
+	hscif1_pins: serial9 {
+		renesas,groups = "hscif1_data_b", "hscif1_clk_b";
+		renesas,function = "hscif1";
+	};
+
+	ether_pins: ether {
+		renesas,groups = "eth_link", "eth_mdio", "eth_rmii";
+		renesas,function = "eth";
+	};
+
+	phy1_pins: phy1 {
+		renesas,groups = "intc_irq1";
+		renesas,function = "intc";
+	};
+
+	avb_pins: avb {
+		renesas,groups = "avb_link", "avb_mdio", "avb_gmii";
+		renesas,function = "avb";
+	};
+
+	sdhi0_pins: sd0 {
+		renesas,groups = "sdhi0_data4", "sdhi0_ctrl";
+		renesas,function = "sdhi0";
+	};
+
+	sdhi2_pins: sd2 {
+		renesas,groups = "sdhi2_data4", "sdhi2_ctrl";
+		renesas,function = "sdhi2";
+	};
+
+	qspi_pins: spi0 {
+		renesas,groups = "qspi_ctrl", "qspi_data4";
+		renesas,function = "qspi";
+	};
+
+	msiof1_pins: spi2 {
+		renesas,groups = "msiof1_clk", "msiof1_sync", "msiof1_rx",
+				 "msiof1_tx", "msiof1_ss1", "msiof1_ss2";
+		renesas,function = "msiof1";
+	};
+
+	msiof2_pins: spi3 {
+		renesas,groups = "msiof2_clk", "msiof2_sync", "msiof2_rx",
+				 "msiof2_tx", "msiof2_ss1", "msiof2_ss2";
+		renesas,function = "msiof2";
+	};
+
+	i2c0_pins: i2c0 {
+		renesas,groups = "i2c0";
+		renesas,function = "i2c0";
+	};
+
+	i2c1_pins: i2c1 {
+		renesas,groups = "i2c1";
+		renesas,function = "i2c1";
+	};
+
+	i2c2_pins: i2c2 {
+		renesas,groups = "i2c2_b";
+		renesas,function = "i2c2";
+	};
+
+	iic3_pins: iic3 {
+		renesas,groups = "iic3";
+		renesas,function = "iic3";
+	};
+
+	vin0_pins: vin0 {
+		renesas,groups = "vin0_data8_b", "vin0_sync_b", "vin0_clk_b";
+		renesas,function = "vin0";
+	};
+
+	vin0_pins: vin0 {
+		renesas,groups = "vin0_data24", "vin0_sync_b", "vin0_field",
+				 "vin0_clkenb", "vin0_clk_b";
+		renesas,function = "vin0";
+	};
+
+	vin1_pins: vin1 {
+		renesas,groups = "vin1_data8", "vin1_clk";
+		renesas,function = "vin1";
+	};
+
+	usb0_pins: usb0 {
+		renesas,groups = "usb0", "usb0_ovc_vbus";
+		renesas,function = "usb0";
+	};
+
+	usb1_pins: usb1 {
+		renesas,groups = "usb1";
+		renesas,function = "usb1";
+	};
+
+	usb2_pins: usb2 {
+		renesas,groups = "usb2";
+		renesas,function = "usb2";
+	};
+
+	can0_pins: can0 {
+		renesas,groups = "can0_data_b";
+		renesas,function = "can0";
+	};
+
+	can1_pins: can1 {
+		renesas,groups = "can1_data_b";
+		renesas,function = "can1";
+	};
+};
+
+&ether {
+	pinctrl-0 = <&ether_pins &phy1_pins>;
+	pinctrl-names = "default";
+
+	phy-handle = <&phy1>;
+	renesas,ether-link-active-low;
+	status = "okay";
+
+	phy1: ethernet-phy@1 {
+		reg = <1>;
+		interrupt-parent = <&irqc0>;
+		interrupts = <1 IRQ_TYPE_LEVEL_LOW>;
+		micrel,led-mode = <1>;
+	};
+};
+
+&avb {
+	pinctrl-0 = <&avb_pins>;
+	pinctrl-names = "default";
+
+	renesas,no-ether-link;
+	renesas,phy = <7>;
+	phy-int-gpio = <&gpio2 15 GPIO_ACTIVE_LOW>;
+	status = "okay";
+};
+
+&qspi {
+	pinctrl-0 = <&qspi_pins>;
+	pinctrl-names = "default";
+
+	status = "okay";
+
+	flash: flash@0 {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		compatible = "spansion,s25fl512s";
+		reg = <0>;
+		spi-max-frequency = <30000000>;
+		spi-tx-bus-width = <4>;
+		spi-rx-bus-width = <4>;
+		m25p,fast-read;
+		spi-cpol;
+		spi-cpha;
+
+		partition@0 {
+			label = "loader";
+			reg = <0x00000000 0x00080000>;
+			read-only;
+		};
+		partition@40000 {
+			label = "user";
+			reg = <0x00080000 0x00580000>;
+			read-only;
+		};
+		partition@440000 {
+			label = "flash";
+			reg = <0x00600000 0x03a00000>;
+		};
+	};
+};
+
+&msiof1 {
+	pinctrl-0 = <&msiof1_pins>;
+	pinctrl-names = "default";
+	status = "okay";
+	cs-gpios = <&gpio4 9 0>;
+};
+
+&msiof2 {
+	pinctrl-0 = <&msiof2_pins>;
+	pinctrl-names = "default";
+	status = "okay";
+	cs-gpios = <&gpio0 26 0>;
+};
+
+&scifa0 {
+	pinctrl-0 = <&scifa0_pins>;
+	pinctrl-names = "default";
+	status = "okay";
+};
+
+&scifa1 {
+	pinctrl-0 = <&scifa1_pins>;
+	pinctrl-names = "default";
+	status = "okay";
+};
+
+&scifa2 {
+	pinctrl-0 = <&scifa2_pins>;
+	pinctrl-names = "default";
+	status = "okay";
+};
+
+&hscif1 {
+	pinctrl-0 = <&hscif1_pins>;
+	pinctrl-names = "default";
+	status = "okay";
+};
+
+&sdhi0 {
+	pinctrl-0 = <&sdhi0_pins>;
+	pinctrl-names = "default";
+
+	vmmc-supply = <&vcc_sdhi0>;
+	vqmmc-supply = <&vccq_sdhi0>;
+	cd-gpios = <&gpio3 6 GPIO_ACTIVE_LOW>;
+	status = "okay";
+};
+
+&sdhi2 {
+	pinctrl-0 = <&sdhi2_pins>;
+	pinctrl-names = "default";
+
+	vmmc-supply = <&vcc_sdhi2>;
+	vqmmc-supply = <&vccq_sdhi2>;
+	cd-gpios = <&gpio3 22 GPIO_ACTIVE_LOW>;
+	status = "okay";
+};
+
+&cpu0 {
+	cpu0-supply = <&vdd_dvfs>;
+};
+
+&i2c0 {
+	pinctrl-0 = <&i2c0_pins>;
+	pinctrl-names = "default";
+
+	clock-frequency = <400000>;
+	status = "okay";
+};
+
+&i2c1 {
+	pinctrl-0 = <&i2c1_pins>;
+	pinctrl-names = "default";
+
+	clock-frequency = <400000>;
+	status = "okay";
+
+	at24@50 {
+		compatible = "at24,24c16";
+		pagesize = <16>;
+		reg = <0x50>;
+	};
+};
+
+&i2c2 {
+	pinctrl-0 = <&i2c2_pins>;
+	pinctrl-names = "default";
+
+	clock-frequency = <400000>;
+	status = "okay";
+
+	at24@50 {
+		compatible = "at24,24c16";
+		pagesize = <16>;
+		reg = <0x50>;
+	};
+};
+
+&iic3 {
+	pinctrl-0 = <&iic3_pins>;
+	pinctrl-names = "default";
+	status = "okay";
+
+	pmic@58 {
+		compatible = "dlg,da9063";
+		reg = <0x58>;
+		interrupt-parent = <&irqc0>;
+		interrupts = <2 IRQ_TYPE_LEVEL_LOW>;
+
+		regulators {
+			vddcore_reg: bcores-merged {
+				regulator-min-microvolt = <1500000>;
+				regulator-max-microvolt = <1500000>;
+				regulator-always-on;
+			};
+
+			vdd_ddr3_reg: bpro {
+				regulator-min-microvolt = <750000>;
+				regulator-max-microvolt = <750000>;
+				regulator-always-on;
+			};
+
+			vdd_3v3_reg: bperi {
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <1800000>;
+				regulator-always-on;
+			};
+
+
+			vdd_buckmem_reg: bmem-bio-merged {
+				regulator-min-microvolt = <3300000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+			};
+
+			vcc_1v8_iso: ldo2 {
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <1800000>;
+				regulator-always-on;
+			};
+
+			vcc_3v3_sd0: ldo3 {
+				regulator-min-microvolt = <3300000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+			};
+
+			vcc_3v3_sd2: ldo4 {
+				regulator-min-microvolt = <3300000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+			};
+
+			vcc_3v3_io: ldo5 {
+				regulator-min-microvolt = <3300000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+			};
+
+			vcc_1v8_io: ldo7 {
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <1800000>;
+				regulator-always-on;
+			};
+
+			vdd_rgmii_io: ldo11 {
+				regulator-min-microvolt = <3000000>;
+				regulator-max-microvolt = <3000000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+		};
+
+		rtc {
+			compatible = "dlg,da9063-rtc";
+		};
+
+		wdt {
+			compatible = "dlg,da9063-watchdog";
+		};
+	};
+
+	vdd_dvfs: regulator@68 {
+		compatible = "diasemi,da9210";
+		reg = <0x68>;
+
+		regulator-min-microvolt = <1000000>;
+		regulator-max-microvolt = <1000000>;
+		regulator-boot-on;
+		regulator-always-on;
+	};
+};
+
+&usbphy {
+	status = "okay";
+};
+
+&xhci {
+	status = "okay";
+};
+
+&pci0 {
+	pinctrl-0 = <&usb0_pins>;
+	pinctrl-names = "default";
+	status = "okay";
+};
+
+&pci1 {
+	pinctrl-0 = <&usb1_pins>;
+	pinctrl-names = "default";
+	status = "okay";
+};
+
+&pci2 {
+	pinctrl-0 = <&usb2_pins>;
+	pinctrl-names = "default";
+	status = "okay";
+};
+
+&pcie_bus_clk {
+	status = "okay";
+};
+
+&pciec {
+	status = "okay";
+};
+
+&can0 {
+	pinctrl-0 = <&can0_pins>;
+	pinctrl-names = "default";
+	renesas,can-clock-select = <0x0>;
+	status = "okay";
+};
+
+&can1 {
+	pinctrl-0 = <&can1_pins>;
+	pinctrl-names = "default";
+	renesas,can-clock-select = <0x0>;
+	status = "okay";
+};
diff --git a/arch/arm/configs/shmobile_defconfig b/arch/arm/configs/shmobile_defconfig
index 85ad251..23f71d3 100644
--- a/arch/arm/configs/shmobile_defconfig
+++ b/arch/arm/configs/shmobile_defconfig
@@ -25,6 +25,7 @@ CONFIG_MACH_LAGER=y
 CONFIG_MACH_GOSE=y
 CONFIG_MACH_ALT=y
 CONFIG_MACH_SILK=y
+CONFIG_MACH_R8A7790STOUT=y
 CONFIG_MACH_MARZEN=y
 CONFIG_MACH_PORTER=y
 CONFIG_SHMOBILE_TIMER_HZ=100
diff --git a/arch/arm/mach-shmobile/Kconfig b/arch/arm/mach-shmobile/Kconfig
index 7c15245..d9ecab9 100644
--- a/arch/arm/mach-shmobile/Kconfig
+++ b/arch/arm/mach-shmobile/Kconfig
@@ -70,6 +70,11 @@ config MACH_LAGER
 	select MICREL_PHY if SH_ETH
 	select SND_SOC_AK4642 if SND_SIMPLE_CARD
 
+config MACH_R8A7790STOUT
+	bool "R8A7790-stout board"
+	depends on ARCH_R8A7790
+	select MICREL_PHY if SH_ETH
+
 config MACH_GOSE
 	bool "Gose board"
 	depends on ARCH_R8A7793
diff --git a/arch/arm/mach-shmobile/Makefile b/arch/arm/mach-shmobile/Makefile
index 43b4025..5705ed6 100644
--- a/arch/arm/mach-shmobile/Makefile
+++ b/arch/arm/mach-shmobile/Makefile
@@ -74,6 +74,7 @@ ifdef CONFIG_ARCH_SHMOBILE_MULTI
 obj-$(CONFIG_MACH_GENMAI)	+= board-genmai-reference.o
 obj-$(CONFIG_MACH_KOELSCH)	+= board-koelsch-reference.o
 obj-$(CONFIG_MACH_LAGER)	+= board-lager-reference.o
+obj-$(CONFIG_MACH_R8A7790STOUT)	+= board-r8a7790stout-reference.o
 obj-$(CONFIG_MACH_GOSE)		+= board-gose-reference.o
 obj-$(CONFIG_MACH_ALT)		+= board-alt-reference.o
 obj-$(CONFIG_MACH_SILK)		+= board-silk-reference.o
diff --git a/arch/arm/mach-shmobile/board-r8a7790stout-reference.c b/arch/arm/mach-shmobile/board-r8a7790stout-reference.c
new file mode 100644
index 0000000..3dc5805
--- /dev/null
+++ b/arch/arm/mach-shmobile/board-r8a7790stout-reference.c
@@ -0,0 +1,731 @@
+/*
+ * R8A7790-stout board support - Reference DT implementation
+ *
+ * Copyright (C) 2015 Renesas Electronics Europe GmbH
+ * Copyright (C) 2015 Renesas Electronics Corporation
+ * Copyright (C) 2015 Cogent Embedded, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#include <linux/dma-mapping.h>
+#include <linux/gpio.h>
+#include <linux/i2c.h>
+#include <linux/init.h>
+#include <linux/micrel_phy.h>
+#include <linux/mfd/tmio.h>
+#include <linux/mmc/host.h>
+#include <linux/mmc/sh_mobile_sdhi.h>
+#include <linux/of_gpio.h>
+#include <linux/of_platform.h>
+#include <linux/phy.h>
+#include <linux/platform_data/camera-rcar.h>
+#include <linux/platform_data/rcar-du.h>
+#include <linux/platform_data/usb-rcar-gen2-phy.h>
+#include <linux/serial_sci.h>
+#include <linux/sh_dma.h>
+#include <linux/spi/flash.h>
+#include <linux/spi/sh_msiof.h>
+#include <linux/spi/spi.h>
+#include <linux/usb/phy.h>
+#if IS_ENABLED(CONFIG_VIDEO_RENESAS_VSP1) && \
+!defined(CONFIG_DRM_RCAR_DU_CONNECT_VSP)
+#include <linux/platform_data/vsp1.h>
+#endif
+#include <media/soc_camera.h>
+#include <asm/mach/arch.h>
+#include <sound/rcar_snd.h>
+#include <sound/simple_card.h>
+
+#include "clock.h"
+#include "common.h"
+#include "dma-register.h"
+#include "irqs.h"
+#include "r8a7790.h"
+#include "rcar-gen2.h"
+
+/* DU */
+static struct rcar_du_encoder_data r8a7790stout_du_encoders[] = {
+	{
+		.type = RCAR_DU_ENCODER_NONE,
+		.output = RCAR_DU_OUTPUT_LVDS0,
+		.connector.lvds.panel = {
+			.width_mm = 229,
+			.height_mm = 149,
+			.lvds_mode = 0,
+			.mode = {
+				.clock = 65000,
+				.hdisplay = 1280,
+				.hsync_start = 1360,
+				.hsync_end = 1400,
+				.htotal = 1440,
+				.vdisplay = 800,
+				.vsync_start = 814,
+				.vsync_end = 824,
+				.vtotal = 838,
+				.flags = 0,
+			},
+		},
+	}, {
+		.type = RCAR_DU_ENCODER_NONE,
+		.output = RCAR_DU_OUTPUT_LVDS1,
+		.connector.lvds.panel = {
+			.width_mm = 229,
+			.height_mm = 149,
+			.lvds_mode = 0,
+			.mode = {
+				.clock = 65000,
+				.hdisplay = 1280,
+				.hsync_start = 1360,
+				.hsync_end = 1400,
+				.htotal = 1440,
+				.vdisplay = 800,
+				.vsync_start = 814,
+				.vsync_end = 824,
+				.vtotal = 838,
+				.flags = 0,
+			},
+		},
+	}, {
+		.type = RCAR_DU_ENCODER_HDMI,
+		.output = RCAR_DU_OUTPUT_DPAD0,
+	},
+};
+
+static struct rcar_du_crtc_data r8a7790stout_du_crtcs[] = {
+	{
+		/* LVDS0 */
+		.exclk = 0, /* 148500000 */
+		.init_conn_type = DRM_MODE_CONNECTOR_LVDS,
+#ifdef CONFIG_DRM_RCAR_DU_CONNECT_VSP
+		.vsp = CONFIG_DRM_RCAR_DU0_USE_VSPDU_CH,
+#endif
+	}, {
+		/* RGB */
+		.exclk =  0, /* 148500000 */
+		.init_conn_type = DRM_MODE_CONNECTOR_HDMIA,
+#ifdef CONFIG_DRM_RCAR_DU_CONNECT_VSP
+		.vsp = CONFIG_DRM_RCAR_DU1_USE_VSPDU_CH,
+#endif
+	}, {
+		/* LVDS1 */
+		.exclk = 0, /* 148500000 */
+		.init_conn_type = DRM_MODE_CONNECTOR_LVDS,
+#ifdef CONFIG_DRM_RCAR_DU_CONNECT_VSP
+		.vsp = CONFIG_DRM_RCAR_DU2_USE_VSPDU_CH,
+#endif
+	},
+};
+
+static struct rcar_du_platform_data r8a7790stout_du_pdata = {
+	.encoders = r8a7790stout_du_encoders,
+	.num_encoders = ARRAY_SIZE(r8a7790stout_du_encoders),
+	.crtcs = r8a7790stout_du_crtcs,
+	.num_crtcs = ARRAY_SIZE(r8a7790stout_du_crtcs),
+#ifdef CONFIG_DRM_FBDEV_CRTC
+	.fbdev_crtc = 1,
+#endif
+	.i2c_ch = 2,
+};
+
+static const struct resource du_resources[] __initconst = {
+	DEFINE_RES_MEM(0xfeb00000, 0x70000),
+	DEFINE_RES_MEM_NAMED(0xfeb90000, 0x1c, "lvds.0"),
+	DEFINE_RES_MEM_NAMED(0xfeb94000, 0x1c, "lvds.1"),
+	DEFINE_RES_IRQ(gic_spi(256)),
+	DEFINE_RES_IRQ(gic_spi(268)),
+	DEFINE_RES_IRQ(gic_spi(269)),
+};
+
+static void __init r8a7790stout_add_du_device(void)
+{
+	struct platform_device_info info = {
+		.name = "rcar-du-r8a7790",
+		.id = -1,
+		.res = du_resources,
+		.num_res = ARRAY_SIZE(du_resources),
+		.data = &r8a7790stout_du_pdata,
+		.size_data = sizeof(r8a7790stout_du_pdata),
+		.dma_mask = DMA_BIT_MASK(32),
+	};
+
+	platform_device_register_full(&info);
+}
+
+/*
+ * This is a really crude hack to provide clkdev support to platform
+ * devices until they get moved to DT.
+ */
+static const struct clk_name clk_names[] __initconst = {
+	{ "cmt0", NULL, "sh_cmt.0" },
+	{ "du0", "du.0", "rcar-du-r8a7790" },
+	{ "du1", "du.1", "rcar-du-r8a7790" },
+	{ "du2", "du.2", "rcar-du-r8a7790" },
+	{ "lvds0", "lvds.0", "rcar-du-r8a7790" },
+	{ "lvds1", "lvds.1", "rcar-du-r8a7790" },
+	{ "hsusb", NULL, "usb_phy_rcar_gen2" },
+#if !IS_ENABLED(CONFIG_RAVB)
+	{ "vin0", NULL, "r8a7790-vin.0" },
+	{ "vin1", NULL, "r8a7790-vin.1" },
+#endif
+	{ "vspr", NULL, NULL },
+	{ "vsps", NULL, NULL },
+#if IS_ENABLED(CONFIG_VIDEO_RENESAS_VSP1) && \
+!defined(CONFIG_DRM_RCAR_DU_CONNECT_VSP)
+	{ "vsp1-du0", NULL, "vsp1.2" },
+	{ "vsp1-du1", NULL, "vsp1.3" },
+#else
+	{ "vsp1-du0", NULL, NULL },
+	{ "vsp1-du1", NULL, NULL },
+#endif
+	{ "vcp1", NULL, NULL },
+	{ "vcp0", NULL, NULL },
+	{ "vpc1", NULL, NULL },
+	{ "vpc0", NULL, NULL },
+	{ "tddmac", NULL, NULL },
+	{ "fdp2", NULL, NULL },
+	{ "fdp1", NULL, NULL },
+	{ "fdp0", NULL, NULL },
+	{ "pvrsrvkm", NULL, "pvrsrvkm" },
+	{ "ehci", NULL, "pci-rcar-gen2.0" },
+};
+
+/*
+ * This is a really crude hack to work around core platform clock issues
+ */
+static const struct clk_name clk_enables[] __initconst = {
+#if IS_ENABLED(CONFIG_RAVB)
+	{ "avb", NULL, "e6800000.ethernet" },
+#endif
+	{ "ehci", NULL, "pci-rcar-gen2.1" },
+	{ "ehci", NULL, "pci-rcar-gen2.2" },
+	{ "dmal", NULL, "sh-dma-engine.0" },
+	{ "dmah", NULL, "sh-dma-engine.1" },
+	{ "sys-dmac1", NULL, "sh-dma-engine.2" },
+	{ "sys-dmac0", NULL, "sh-dma-engine.3" },
+	{ "ssp_dev", NULL, "ssp_dev" },
+};
+
+#define DMAE_CHANNEL(a, b)			\
+{						\
+	.offset		= (a) - 0x20,		\
+	.dmars		= (a) - 0x20 + 0x40,	\
+	.chclr_bit	= (b),			\
+	.chclr_offset	= 0x80 - 0x20,		\
+}
+
+/* Sys-DMAC */
+#define SYS_DMAC_SLAVE(_id, _bit, _addr, toffset, roffset, t, r)	\
+{								\
+	.slave_id	= SYS_DMAC_SLAVE_## _id ##_TX,		\
+	.addr		= _addr + toffset,			\
+	.chcr		= CHCR_TX(XMIT_SZ_## _bit ##BIT),	\
+	.mid_rid	= t,					\
+}, {								\
+	.slave_id	= SYS_DMAC_SLAVE_## _id ##_RX,		\
+	.addr		= _addr + roffset,			\
+	.chcr		= CHCR_RX(XMIT_SZ_## _bit ##BIT),	\
+	.mid_rid	= r,					\
+}
+
+#define SYS_DMAC_SLAVE_TX(_id, _bit, _addr, toffset, roffset, t, r)	\
+{								\
+	.slave_id	= SYS_DMAC_SLAVE_## _id ##_TX,		\
+	.addr		= _addr + toffset,			\
+	.chcr		= CHCR_TX(XMIT_SZ_## _bit ##BIT),	\
+	.mid_rid	= t,					\
+}
+
+static const struct sh_dmae_slave_config r8a7790_sys_dmac_slaves[] = {
+	SYS_DMAC_SLAVE(SDHI0, 256, 0xee100000, 0x60, 0x2060, 0xcd, 0xce),
+	SYS_DMAC_SLAVE(SDHI2, 256, 0xee140000, 0x30, 0x2030, 0xc1, 0xc2),
+	SYS_DMAC_SLAVE(SCIF0, 8, 0xe6e60000, 0xc, 0x14, 0x29, 0x2a),
+	SYS_DMAC_SLAVE(SCIF1, 8, 0xe6e68000, 0xc, 0x14, 0x2d, 0x2e),
+	SYS_DMAC_SLAVE(SCIFA0, 8, 0xe6c40000, 0x20, 0x24, 0x21, 0x22),
+	SYS_DMAC_SLAVE(SCIFA1, 8, 0xe6c50000, 0x20, 0x24, 0x25, 0x26),
+	SYS_DMAC_SLAVE(SCIFA2, 8, 0xe6c60000, 0x20, 0x24, 0x27, 0x28),
+	SYS_DMAC_SLAVE(SCIFB0, 8, 0xe6c20000, 0x40, 0x60, 0x3d, 0x3e),
+	SYS_DMAC_SLAVE(SCIFB1, 8, 0xe6c30000, 0x40, 0x60, 0x19, 0x1a),
+	SYS_DMAC_SLAVE(SCIFB2, 8, 0xe6ce0000, 0x40, 0x60, 0x1d, 0x1e),
+	SYS_DMAC_SLAVE(HSCIF0, 8, 0xe62c0000, 0xc, 0x14, 0x39, 0x3a),
+	SYS_DMAC_SLAVE(HSCIF1, 8, 0xe62c8000, 0xc, 0x14, 0x4d, 0x4e),
+	SYS_DMAC_SLAVE(MSIOF0, 32, 0xe6e20000, 0x50, 0x60, 0x51, 0x52),
+	SYS_DMAC_SLAVE(MSIOF1, 32, 0xe6e10000, 0x50, 0x60, 0x55, 0x56),
+	SYS_DMAC_SLAVE(MSIOF2, 32, 0xe6e00000, 0x50, 0x60, 0x41, 0x42),
+	SYS_DMAC_SLAVE(MSIOF3, 32, 0xe6c90000, 0x50, 0x60, 0x45, 0x46),
+};
+
+static const struct sh_dmae_channel r8a7790_sys_dmac_channels[] = {
+	DMAE_CHANNEL(0x8000, 0),
+	DMAE_CHANNEL(0x8080, 1),
+	DMAE_CHANNEL(0x8100, 2),
+	DMAE_CHANNEL(0x8180, 3),
+	DMAE_CHANNEL(0x8200, 4),
+	DMAE_CHANNEL(0x8280, 5),
+	DMAE_CHANNEL(0x8300, 6),
+	DMAE_CHANNEL(0x8380, 7),
+	DMAE_CHANNEL(0x8400, 8),
+	DMAE_CHANNEL(0x8480, 9),
+	DMAE_CHANNEL(0x8500, 10),
+	DMAE_CHANNEL(0x8580, 11),
+	DMAE_CHANNEL(0x8600, 12),
+	DMAE_CHANNEL(0x8680, 13),
+	DMAE_CHANNEL(0x8700, 14),
+};
+
+static struct sh_dmae_pdata r8a7790_sys_dmac_platform_data = {
+	.slave		= r8a7790_sys_dmac_slaves,
+	.slave_num	= ARRAY_SIZE(r8a7790_sys_dmac_slaves),
+	.channel	= r8a7790_sys_dmac_channels,
+	.channel_num	= ARRAY_SIZE(r8a7790_sys_dmac_channels),
+	.ts_low_shift	= TS_LOW_SHIFT,
+	.ts_low_mask	= TS_LOW_BIT << TS_LOW_SHIFT,
+	.ts_high_shift	= TS_HI_SHIFT,
+	.ts_high_mask	= TS_HI_BIT << TS_HI_SHIFT,
+	.ts_shift	= dma_ts_shift,
+	.ts_shift_num	= ARRAY_SIZE(dma_ts_shift),
+	.dmaor_init	= DMAOR_DME,
+	.chclr_present	= 1,
+	.chclr_bitwise	= 1,
+	.fourty_bits_addr = 1,
+};
+
+static struct resource r8a7790_sys_dmac_resources[] = {
+	/* Channel registers and DMAOR for low */
+	DEFINE_RES_MEM(0xe6700020, 0x8763 - 0x20),
+	DEFINE_RES_IRQ(gic_spi(197)),
+	DEFINE_RES_NAMED(gic_spi(200), 15, NULL, IORESOURCE_IRQ),
+
+	/* Channel registers and DMAOR for high */
+	DEFINE_RES_MEM(0xe6720020, 0x8763 - 0x20),
+	DEFINE_RES_IRQ(gic_spi(220)),
+	DEFINE_RES_NAMED(gic_spi(216), 4, NULL, IORESOURCE_IRQ),
+	DEFINE_RES_NAMED(gic_spi(308), 11, NULL, IORESOURCE_IRQ),
+};
+
+#define r8a7790_register_sys_dmac(id)				\
+	platform_device_register_resndata(			\
+		&platform_bus, "sh-dma-engine", 2 + id,		\
+		&r8a7790_sys_dmac_resources[id * 3],	id * 1 + 3,	\
+		&r8a7790_sys_dmac_platform_data,		\
+		sizeof(r8a7790_sys_dmac_platform_data))
+
+static void __init r8a7790stout_add_dmac_prototype(void)
+{
+	r8a7790_register_sys_dmac(0);
+	r8a7790_register_sys_dmac(1);
+}
+
+static struct sh_mobile_sdhi_info sdhi0_info = {
+	.dma_slave_tx   = SYS_DMAC_SLAVE_SDHI0_TX,
+	.dma_slave_rx   = SYS_DMAC_SLAVE_SDHI0_RX,
+	.dma_rx_offset  = 0x2000,
+
+	.tmio_caps	= MMC_CAP_SD_HIGHSPEED | MMC_CAP_SDIO_IRQ |
+			  MMC_CAP_POWER_OFF_CARD,
+	.tmio_flags	= TMIO_MMC_HAS_IDLE_WAIT |
+			  TMIO_MMC_WRPROTECT_DISABLE,
+	.tmio_ocr_mask	= MMC_VDD_32_33 | MMC_VDD_33_34,
+};
+
+static struct sh_mobile_sdhi_info sdhi2_info = {
+	.dma_slave_tx   = SYS_DMAC_SLAVE_SDHI2_TX,
+	.dma_slave_rx   = SYS_DMAC_SLAVE_SDHI2_RX,
+	.dma_rx_offset  = 0x2000,
+
+	.tmio_caps	= MMC_CAP_SD_HIGHSPEED | MMC_CAP_SDIO_IRQ |
+			  MMC_CAP_POWER_OFF_CARD,
+	.tmio_flags	= TMIO_MMC_HAS_IDLE_WAIT |
+			  TMIO_MMC_WRPROTECT_DISABLE,
+	.tmio_ocr_mask	= MMC_VDD_32_33 | MMC_VDD_33_34,
+};
+
+/* SCIF */
+#define SCIF_PD(scif_type, index, scif_index)				\
+static struct plat_sci_port scif##index##_platform_data = {	\
+	.type		= PORT_##scif_type,			\
+	.flags		= UPF_BOOT_AUTOCONF | UPF_IOREMAP,	\
+	.scscr		= SCSCR_RE | SCSCR_TE,			\
+	.dma_slave_tx	= SYS_DMAC_SLAVE_##scif_type##scif_index##_TX,	\
+	.dma_slave_rx	= SYS_DMAC_SLAVE_##scif_type##scif_index##_RX,	\
+}
+
+#define PDATA_SCIF(index, baseaddr, irq, i) SCIF_PD(SCIF, index, i)
+#define PDATA_SCIFA(index, baseaddr, irq, i) SCIF_PD(SCIFA, index, i)
+#define PDATA_SCIFB(index, baseaddr, irq, i) SCIF_PD(SCIFB, index, i)
+#define PDATA_HSCIF(index, baseaddr, irq, i) SCIF_PD(HSCIF, index, i)
+
+PDATA_SCIFA(0, 0xe6c40000, gic_spi(144), 0); /* SCIFA0 */
+PDATA_SCIFA(1, 0xe6c50000, gic_spi(145), 1); /* SCIFA1 */
+PDATA_SCIFB(2, 0xe6c20000, gic_spi(148), 0); /* SCIFB0 */
+PDATA_SCIFB(3, 0xe6c30000, gic_spi(149), 1); /* SCIFB1 */
+PDATA_SCIFB(4, 0xe6ce0000, gic_spi(150), 2); /* SCIFB2 */
+PDATA_SCIFA(5, 0xe6c60000, gic_spi(151), 2); /* SCIFA2 */
+PDATA_SCIF(6,  0xe6e60000, gic_spi(152), 0); /* SCIF0 */
+PDATA_SCIF(7,  0xe6e68000, gic_spi(153), 1); /* SCIF1 */
+PDATA_HSCIF(8, 0xe62c0000, gic_spi(154), 0); /* HSCIF0 */
+PDATA_HSCIF(9, 0xe62c8000, gic_spi(155), 1); /* HSCIF1 */
+
+#define SCIF_AD(scif_type, index, baseaddr)		\
+	OF_DEV_AUXDATA("renesas," scif_type "-r8a7790", baseaddr, \
+			"sh-sci." # index, &scif##index##_platform_data)
+
+#define AUXDATA_SCIF(index, baseaddr, irq) SCIF_AD("scif", index, baseaddr)
+#define AUXDATA_SCIFA(index, baseaddr, irq) SCIF_AD("scifa", index, baseaddr)
+#define AUXDATA_SCIFB(index, baseaddr, irq) SCIF_AD("scifb", index, baseaddr)
+#define AUXDATA_HSCIF(index, baseaddr, irq) SCIF_AD("hscif", index, baseaddr)
+
+/* Internal PCI0 */
+static const struct resource pci0_resources[] __initconst = {
+	DEFINE_RES_MEM(0xee090000, 0x10000),	/* CFG */
+	DEFINE_RES_MEM(0xee080000, 0x10000),	/* MEM */
+	DEFINE_RES_IRQ(gic_spi(108)),
+};
+
+static const struct platform_device_info pci0_info __initconst = {
+	.parent		= &platform_bus,
+	.name		= "pci-rcar-gen2",
+	.id		= 0,
+	.res		= pci0_resources,
+	.num_res	= ARRAY_SIZE(pci0_resources),
+	.dma_mask	= DMA_BIT_MASK(32),
+};
+
+static void __init r8a7790stout_add_usb0_device(void)
+{
+	usb_bind_phy("pci-rcar-gen2.0", 0, "usb_phy_rcar_gen2");
+	platform_device_register_full(&pci0_info);
+}
+
+/* USBHS PHY */
+static const struct rcar_gen2_phy_platform_data usbhs_phy_pdata __initconst = {
+	.chan0_pci = 1,	/* Channel 0 is PCI USB */
+	.gpio_vbus = -1,
+	.wakeup = false,
+#if !IS_ENABLED(CONFIG_USB_XHCI_HCD)
+	.chan2_pci = 1,	/* Channel 2 is PCI USB */
+#else
+	.chan2_pci = 0,	/* Channel 2 is USB3.0 */
+#endif
+};
+
+static const struct resource usbhs_phy_resources[] __initconst = {
+	DEFINE_RES_MEM(0xe6590100, 0x100),
+};
+
+/* Internal PCI1 */
+static const struct resource pci1_resources[] __initconst = {
+	DEFINE_RES_MEM(0xee0b0000, 0x10000),	/* CFG */
+	DEFINE_RES_MEM(0xee0a0000, 0x10000),	/* MEM */
+	DEFINE_RES_IRQ(gic_spi(112)),
+};
+
+static const struct platform_device_info pci1_info __initconst = {
+	.parent		= &platform_bus,
+	.name		= "pci-rcar-gen2",
+	.id		= 1,
+	.res		= pci1_resources,
+	.num_res	= ARRAY_SIZE(pci1_resources),
+	.dma_mask	= DMA_BIT_MASK(32),
+};
+
+static void __init r8a7790stout_add_usb1_device(void)
+{
+	usb_bind_phy("pci-rcar-gen2.1", 0, "usb_phy_rcar_gen2");
+	platform_device_register_full(&pci1_info);
+}
+
+/* Internal PCI2 */
+static const struct resource pci2_resources[] __initconst = {
+	DEFINE_RES_MEM(0xee0d0000, 0x10000),	/* CFG */
+	DEFINE_RES_MEM(0xee0c0000, 0x10000),	/* MEM */
+	DEFINE_RES_IRQ(gic_spi(113)),
+};
+
+static const struct platform_device_info pci2_info __initconst = {
+	.parent		= &platform_bus,
+	.name		= "pci-rcar-gen2",
+	.id		= 2,
+	.res		= pci2_resources,
+	.num_res	= ARRAY_SIZE(pci2_resources),
+	.dma_mask	= DMA_BIT_MASK(32),
+};
+
+#if !IS_ENABLED(CONFIG_USB_XHCI_HCD)
+static void __init r8a7790stout_add_usb2_device(void)
+{
+	usb_bind_phy("pci-rcar-gen2.2", 0, "usb_phy_rcar_gen2");
+	platform_device_register_full(&pci2_info);
+};
+#endif
+
+#if !IS_ENABLED(CONFIG_RAVB)
+/* VIN */
+static const struct resource vin_resources[] __initconst = {
+	/* VIN0 */
+	DEFINE_RES_MEM(0xe6ef0000, 0x1000),
+	DEFINE_RES_IRQ(gic_spi(188)),
+	/* VIN1 */
+	DEFINE_RES_MEM(0xe6ef1000, 0x1000),
+	DEFINE_RES_IRQ(gic_spi(189)),
+};
+
+static void __init r8a7790stout_add_vin_device(unsigned idx,
+					struct rcar_vin_platform_data *pdata)
+{
+	struct platform_device_info vin_info = {
+		.parent		= &platform_bus,
+		.name		= "r8a7790-vin",
+		.id		= idx,
+		.res		= &vin_resources[idx * 2],
+		.num_res	= 2,
+		.dma_mask	= DMA_BIT_MASK(32),
+		.data		= pdata,
+		.size_data	= sizeof(*pdata),
+	};
+
+	BUG_ON(idx > 1);
+
+	platform_device_register_full(&vin_info);
+}
+
+#define R8A7790stout_CAMERA(idx, name, addr, pdata, flag)			\
+static struct i2c_board_info i2c_cam##idx##_device = {			\
+	I2C_BOARD_INFO(name, addr),					\
+};									\
+									\
+static struct rcar_vin_platform_data vin##idx##_pdata = {		\
+	.flags = flag,							\
+};									\
+									\
+static struct soc_camera_link cam##idx##_link = {			\
+	.bus_id = idx,							\
+	.board_info = &i2c_cam##idx##_device,				\
+	.i2c_adapter_id = 2,						\
+	.module_name = name,						\
+	.priv = pdata,							\
+}
+
+R8A7790stout_CAMERA(0, "ov10635", 0x30, NULL, RCAR_VIN_BT601);
+R8A7790stout_CAMERA(1, "adv7180", 0x20, NULL, RCAR_VIN_BT656);
+
+static void __init r8a7790stout_add_camera0_device(void)
+{
+	platform_device_register_data(&platform_bus, "soc-camera-pdrv", 0,
+				      &cam0_link, sizeof(cam0_link));
+	r8a7790stout_add_vin_device(0, &vin0_pdata);
+}
+
+static void __init r8a7790stout_add_camera1_device(void)
+{
+	platform_device_register_data(&platform_bus, "soc-camera-pdrv", 1,
+				      &cam1_link, sizeof(cam1_link));
+	r8a7790stout_add_vin_device(1, &vin1_pdata);
+}
+#endif
+
+/* VSP1 */
+#if IS_ENABLED(CONFIG_VIDEO_RENESAS_VSP1) && \
+!defined(CONFIG_DRM_RCAR_DU_CONNECT_VSP)
+static const struct vsp1_platform_data r8a7790stout_vspr_pdata __initconst = {
+	.features = VSP1_HAS_LUT | VSP1_HAS_SRU,
+	.rpf_count = 5,
+	.uds_count = 1,
+	.wpf_count = 4,
+};
+
+static const struct vsp1_platform_data r8a7790stout_vsps_pdata __initconst = {
+	.features = VSP1_HAS_SRU,
+	.rpf_count = 5,
+	.uds_count = 3,
+	.wpf_count = 4,
+};
+
+static const struct vsp1_platform_data r8a7790stout_vspd0_pdata __initconst = {
+	.features = VSP1_HAS_LIF | VSP1_HAS_LUT,
+	.rpf_count = 4,
+	.uds_count = 1,
+	.wpf_count = 4,
+};
+
+static const struct vsp1_platform_data r8a7790stout_vspd1_pdata __initconst = {
+	.features = VSP1_HAS_LIF | VSP1_HAS_LUT,
+	.rpf_count = 4,
+	.uds_count = 1,
+	.wpf_count = 4,
+};
+
+static const struct vsp1_platform_data * const r8a7790stout_vsp1_pdata[4] __initconst = {
+	&r8a7790stout_vspr_pdata,
+	&r8a7790stout_vsps_pdata,
+	&r8a7790stout_vspd0_pdata,
+	&r8a7790stout_vspd1_pdata,
+};
+
+static const struct resource vspr_resources[] __initconst = {
+	DEFINE_RES_MEM(0xfe920000, 0x8000),
+	DEFINE_RES_IRQ(gic_spi(266)),
+};
+
+static const struct resource vsps_resources[] __initconst = {
+	DEFINE_RES_MEM(0xfe928000, 0x8000),
+	DEFINE_RES_IRQ(gic_spi(267)),
+};
+
+static const struct resource vspd0_resources[] __initconst = {
+	DEFINE_RES_MEM(0xfe930000, 0x8000),
+	DEFINE_RES_IRQ(gic_spi(246)),
+};
+
+static const struct resource vspd1_resources[] __initconst = {
+	DEFINE_RES_MEM(0xfe938000, 0x8000),
+	DEFINE_RES_IRQ(gic_spi(247)),
+};
+
+static const struct resource * const vsp1_resources[4] __initconst = {
+	vspr_resources,
+	vsps_resources,
+	vspd0_resources,
+	vspd1_resources,
+};
+
+static void __init r8a7790stout_add_vsp1_devices(void)
+{
+	struct platform_device_info info = {
+		.name = "vsp1",
+		.size_data = sizeof(*r8a7790stout_vsp1_pdata[0]),
+		.num_res = 2,
+		.dma_mask = DMA_BIT_MASK(32),
+	};
+	unsigned int i;
+
+	for (i = 2; i < ARRAY_SIZE(vsp1_resources); ++i) {
+		info.id = i;
+		info.data = r8a7790stout_vsp1_pdata[i];
+		info.res = vsp1_resources[i];
+
+		platform_device_register_full(&info);
+	}
+}
+#endif
+
+/* MSIOF */
+static struct sh_msiof_spi_info msiof1_info = {
+	.rx_fifo_override       = 256,
+	.num_chipselect         = 1,
+	.dma_tx_id              = SYS_DMAC_SLAVE_MSIOF1_TX,
+	.dma_rx_id              = SYS_DMAC_SLAVE_MSIOF1_RX,
+};
+
+/* MSIOF spidev */
+static const struct spi_board_info spi_bus[] __initconst = {
+	{
+		.modalias	= "spidev",
+		.max_speed_hz	= 6000000,
+		.mode		= SPI_MODE_3,
+		.bus_num	= 2,
+		.chip_select	= 0,
+	},
+};
+
+#define r8a7790stout_add_msiof_device spi_register_board_info
+
+static struct of_dev_auxdata r8a7790stout_auxdata_lookup[] __initdata = {
+	OF_DEV_AUXDATA("renesas,sdhi-r8a7790", 0xee100000, "sdhi0",
+			&sdhi0_info),
+	OF_DEV_AUXDATA("renesas,sdhi-r8a7790", 0xee140000, "sdhi2",
+			&sdhi2_info),
+	AUXDATA_SCIFA(0, 0xe6c40000, gic_spi(144)), /* SCIFA0 */
+	AUXDATA_SCIFA(1, 0xe6c50000, gic_spi(145)), /* SCIFA1 */
+	AUXDATA_SCIFB(2, 0xe6c20000, gic_spi(148)), /* SCIFB0 */
+	AUXDATA_SCIFB(3, 0xe6c30000, gic_spi(149)), /* SCIFB1 */
+	AUXDATA_SCIFB(4, 0xe6ce0000, gic_spi(150)), /* SCIFB2 */
+	AUXDATA_SCIFA(5, 0xe6c60000, gic_spi(151)), /* SCIFA2 */
+	AUXDATA_SCIF(6,  0xe6e60000, gic_spi(152)), /* SCIF0 */
+	AUXDATA_SCIF(7,  0xe6e68000, gic_spi(153)), /* SCIF1 */
+	AUXDATA_HSCIF(8, 0xe62c0000, gic_spi(154)), /* HSCIF0 */
+	AUXDATA_HSCIF(9, 0xe62c8000, gic_spi(155)), /* HSCIF1 */
+	OF_DEV_AUXDATA("renesas,msiof-r8a7790", 0xe6e10000,
+		       "spi_r8a7790_msiof.0", &msiof1_info),
+	{},
+};
+
+static void mmd_write_reg(struct phy_device *dev, int device, int reg, int val)
+{
+	phy_write(dev, 0x0d, device);
+	phy_write(dev, 0x0e, reg);
+	phy_write(dev, 0x0d, (1 << 14) | device);
+	phy_write(dev, 0x0e, val);
+}
+
+static int ksz9031rn_phy_fixup(struct phy_device *dev)
+{
+	/* min tx data delay */
+	mmd_write_reg(dev, 2, 6, 0);
+
+	return 0;
+}
+
+static void __init r8a7790stout_add_standard_devices(void)
+{
+	shmobile_clk_workaround(clk_names, ARRAY_SIZE(clk_names), false);
+	shmobile_clk_workaround(clk_enables, ARRAY_SIZE(clk_enables), true);
+	r8a7790_add_dt_devices();
+
+	r8a7790stout_add_dmac_prototype();
+	of_platform_populate(NULL, of_default_bus_match_table,
+			     r8a7790stout_auxdata_lookup, NULL);
+
+	r8a7790stout_add_du_device();
+	platform_device_register_resndata(&platform_bus, "usb_phy_rcar_gen2",
+					  -1, usbhs_phy_resources,
+					  ARRAY_SIZE(usbhs_phy_resources),
+					  &usbhs_phy_pdata,
+					  sizeof(usbhs_phy_pdata));
+	r8a7790stout_add_usb0_device();
+	r8a7790stout_add_usb1_device();
+#if !IS_ENABLED(CONFIG_USB_XHCI_HCD)
+	r8a7790stout_add_usb2_device();
+#endif
+
+#if !IS_ENABLED(CONFIG_RAVB)
+	r8a7790stout_add_camera0_device();
+	r8a7790stout_add_camera1_device();
+#endif
+
+#if IS_ENABLED(CONFIG_VIDEO_RENESAS_VSP1) && \
+!defined(CONFIG_DRM_RCAR_DU_CONNECT_VSP)
+	r8a7790stout_add_vsp1_devices();
+#endif
+	r8a7790stout_add_msiof_device(spi_bus, ARRAY_SIZE(spi_bus));
+
+	phy_register_fixup_for_uid(PHY_ID_KSZ9031, MICREL_PHY_ID_MASK,
+				   ksz9031rn_phy_fixup);
+}
+
+static const char *r8a7790stout_boards_compat_dt[] __initdata = {
+	"renesas,r8a7790stout",
+	"renesas,r8a7790stout-reference",
+	NULL,
+};
+
+DT_MACHINE_START(R8A7790stout_DT, "r8a7790stout")
+	.smp		= smp_ops(r8a7790_smp_ops),
+	.init_early	= shmobile_init_delay,
+	.init_time	= rcar_gen2_timer_init,
+	.init_machine	= r8a7790stout_add_standard_devices,
+	.init_late	= shmobile_init_late,
+	.reserve	= rcar_gen2_reserve,
+	.dt_compat	= r8a7790stout_boards_compat_dt,
+MACHINE_END
diff --git a/drivers/pinctrl/Kconfig b/drivers/pinctrl/Kconfig
index 6585b37..ed4bb3b 100644
--- a/drivers/pinctrl/Kconfig
+++ b/drivers/pinctrl/Kconfig
@@ -13,6 +13,9 @@ menu "Pin controllers"
 config PINMUX
 	bool "Support pin multiplexing controllers"
 
+config PINMUX_CPLD
+	bool "Support external pin multiplexing controllers"
+
 config PINCONF
 	bool "Support pin configuration controllers"
 
diff --git a/drivers/pinctrl/Makefile b/drivers/pinctrl/Makefile
index fae8945..5ad7361 100644
--- a/drivers/pinctrl/Makefile
+++ b/drivers/pinctrl/Makefile
@@ -4,6 +4,7 @@ ccflags-$(CONFIG_DEBUG_PINCTRL)	+= -DDEBUG
 
 obj-$(CONFIG_PINCTRL)		+= core.o pinctrl-utils.o
 obj-$(CONFIG_PINMUX)		+= pinmux.o
+obj-$(CONFIG_PINMUX_CPLD)	+= pinmux-ext.o
 obj-$(CONFIG_PINCONF)		+= pinconf.o
 ifeq ($(CONFIG_OF),y)
 obj-$(CONFIG_PINCTRL)		+= devicetree.o
diff --git a/drivers/pinctrl/pinmux-ext.c b/drivers/pinctrl/pinmux-ext.c
new file mode 100644
index 0000000..0ba359e
--- /dev/null
+++ b/drivers/pinctrl/pinmux-ext.c
@@ -0,0 +1,299 @@
+/*
+ * r8a7790-stout board FPGA access driver
+ *
+ * Copyright (C) 2015 Renesas Electronics Europe GmbH
+ * Copyright (C) 2015 Renesas Electronics Corporation
+ * Copyright (C) 2015 Cogent Embedded, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#if 0
+#include <linux/i2c.h>
+#include <linux/i2c-mux.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/pinctrl/consumer.h>
+#include <linux/i2c-mux-pinctrl.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#endif
+
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/io.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/phy/phy.h>
+#include <linux/platform_device.h>
+#include <linux/spinlock.h>
+
+#include <linux/gpio.h>
+#include <linux/platform_data/gpio-rcar.h>
+#include "pinmux-ext.h"
+
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/of_gpio.h>
+
+//#include <linux/delay.h>
+#define CPLD_DEBUG
+
+#define CPLD_ADDR_MODE		0x00 /* RW */
+#define CPLD_ADDR_MUX		0x01 /* RW */
+#define CPLD_ADDR_HDMI		0x02 /* RW */
+#define CPLD_ADDR_DIPSW		0x08 /* R */
+#define CPLD_ADDR_VERSION	0xFF /* R */
+
+struct pinmux_ext_priv {
+	struct mutex lock;
+	struct delayed_work work;
+
+	unsigned sclk_gpio;
+	unsigned sstbz_gpio;
+	unsigned mosi_gpio;
+	unsigned miso_gpio;
+
+	u8 cpld_addr;
+};
+
+static u32 cpld_read(struct pinmux_ext_priv *priv, u8 addr)
+{
+	int i;
+	u32 data = 0;
+
+	for (i = 0; i < 8; i++) {
+		/* MSB first */
+		gpio_set_value(priv->mosi_gpio, addr & 0x80);
+		gpio_set_value(priv->sclk_gpio, 1);
+		addr <<= 1;
+		gpio_set_value(priv->sclk_gpio, 0);
+	}
+
+	gpio_set_value(priv->mosi_gpio, 0); /* READ */
+	gpio_set_value(priv->sstbz_gpio, 0);
+	gpio_set_value(priv->sclk_gpio, 1);
+	gpio_set_value(priv->sclk_gpio, 0);
+	gpio_set_value(priv->sstbz_gpio, 1);
+
+	for (i = 0; i < 32; i++) {
+		gpio_set_value(priv->sclk_gpio, 1);
+		data <<= 1;
+		/* MSB first */
+		data |= (!!gpio_get_value(priv->miso_gpio));
+		gpio_set_value(priv->sclk_gpio, 0);
+	}
+
+	return data;
+}
+
+static void cpld_write(struct pinmux_ext_priv *priv, u8 addr, u32 data)
+{
+	int i;
+
+	for (i = 0; i < 32; i++) {
+		 /* MSB first */
+		gpio_set_value(priv->mosi_gpio, data & (1 << 31));
+		gpio_set_value(priv->sclk_gpio, 1);
+		data <<= 1;
+		gpio_set_value(priv->sclk_gpio, 0);
+	}
+
+	for (i = 0; i < 8; i++) {
+		/* MSB first */
+		gpio_set_value(priv->mosi_gpio, addr & 0x80);
+		gpio_set_value(priv->sclk_gpio, 1);
+		addr <<= 1;
+		gpio_set_value(priv->sclk_gpio, 0);
+	}
+
+	gpio_set_value(priv->mosi_gpio, 1); /* WRITE */
+	gpio_set_value(priv->sstbz_gpio, 0);
+	gpio_set_value(priv->sclk_gpio, 1);
+	gpio_set_value(priv->sclk_gpio, 0);
+	gpio_set_value(priv->sstbz_gpio, 1);
+}
+
+static void cpld_init(struct pinmux_ext_priv *priv)
+{
+	gpio_request_one(priv->sclk_gpio, GPIOF_OUT_INIT_LOW, NULL);
+	gpio_request_one(priv->sstbz_gpio, GPIOF_OUT_INIT_HIGH, NULL);
+	gpio_request_one(priv->mosi_gpio, GPIOF_OUT_INIT_LOW, NULL);
+	gpio_request_one(priv->miso_gpio, GPIOF_IN, NULL);
+
+	/* dummy read */
+	cpld_read(priv, CPLD_ADDR_VERSION);
+
+#if defined(CPLD_DEBUG)
+	printk("CPLD version:              0x%08x\n",
+		cpld_read(priv, CPLD_ADDR_VERSION));
+	printk("H2 Mode setting (MD0..28): 0x%08x\n",
+		cpld_read(priv, CPLD_ADDR_MODE));
+	printk("Multiplexer settings:      0x%08x\n",
+		cpld_read(priv, CPLD_ADDR_MUX));
+	printk("HDMI setting:              0x%08x\n",
+		cpld_read(priv, CPLD_ADDR_HDMI));
+	printk("DIPSW (SW3):               0x%08x\n",
+		cpld_read(priv, CPLD_ADDR_DIPSW));
+#endif
+}
+
+static ssize_t cpld_sysfs_read_reg(struct device *dev,
+				   struct device_attribute *attr, char *buf)
+{
+	struct pinmux_ext_priv *priv = dev_get_drvdata(dev);
+
+	return sprintf(buf, "0x%x\n", cpld_read(priv, priv->cpld_addr));
+}
+static ssize_t cpld_sysfs_write_reg(struct device *dev,
+				    struct device_attribute *attr,
+				    const char *buf, size_t len)
+{
+	struct pinmux_ext_priv *priv = dev_get_drvdata(dev);
+	unsigned int val;
+	int ret;
+
+	ret = kstrtouint(buf, 16, &val);
+	if (ret)
+		return ret;
+
+	if (priv->cpld_addr == CPLD_ADDR_MUX) {
+		/* never mask SCIFA0 console */
+		val &= ~MUX_MSK_SCIFA0_USB;
+		val |= MUX_VAL_SCIFA0_USB;
+	}
+
+	cpld_write(priv, priv->cpld_addr, val);
+
+	return len;
+}
+
+static ssize_t cpld_sysfs_get_addr(struct device *dev,
+				   struct device_attribute *attr, char *buf)
+{
+	struct pinmux_ext_priv *priv = dev_get_drvdata(dev);
+
+	return sprintf(buf, "0x%x\n", priv->cpld_addr);
+}
+
+static ssize_t cpld_sysfs_set_addr(struct device *dev,
+				   struct device_attribute *attr,
+				   const char *buf, size_t len)
+{
+	struct pinmux_ext_priv *priv = dev_get_drvdata(dev);
+	unsigned int val;
+	int ret;
+
+	ret = kstrtouint(buf, 16, &val);
+	if (ret)
+		return ret;
+
+	if (!(val == CPLD_ADDR_VERSION || val == CPLD_ADDR_MODE ||
+	      val == CPLD_ADDR_MUX || val == CPLD_ADDR_HDMI ||
+	      val == CPLD_ADDR_DIPSW)) {
+		return -EINVAL;
+	}
+
+	priv->cpld_addr = val;
+
+	return len;
+}
+
+static DEVICE_ATTR(val, S_IRUGO | S_IWUGO, cpld_sysfs_read_reg, cpld_sysfs_write_reg);
+static DEVICE_ATTR(adr, S_IRUGO | S_IWUGO, cpld_sysfs_get_addr, cpld_sysfs_set_addr);
+
+static struct pinmux_ext_priv *pinmux_ext_parse_dt(struct device *dev)
+{
+	struct device_node *np = dev->of_node;
+	struct pinmux_ext_priv *priv;
+
+	priv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);
+	if (!priv)
+		return NULL;
+
+	priv->sclk_gpio = of_get_named_gpio(np, "pinmux-ext,sclk-gpio", 0);
+	if (priv->sclk_gpio < 0)
+		return NULL;
+
+	priv->sstbz_gpio = of_get_named_gpio(np, "pinmux-ext,sstbz-gpio", 0);
+	if (priv->sstbz_gpio < 0)
+		return NULL;
+
+	priv->mosi_gpio = of_get_named_gpio(np, "pinmux-ext,mosi-gpio", 0);
+	if (priv->mosi_gpio < 0)
+		return NULL;
+
+	priv->miso_gpio = of_get_named_gpio(np, "pinmux-ext,miso-gpio", 0);
+	if (priv->miso_gpio < 0)
+		return NULL;
+
+	return priv;
+}
+
+static int pinmux_ext_probe(struct platform_device *pdev)
+{
+//<------>struct pinctrl *pinctrl;
+	struct device *dev = &pdev->dev;
+	struct pinmux_ext_priv *priv;
+	int ret;
+
+	priv = pinmux_ext_parse_dt(dev);
+	if (!priv)
+		return -EINVAL;
+
+	cpld_init(priv);
+
+	dev_set_drvdata(dev, priv);
+
+	ret = device_create_file(dev, &dev_attr_val);
+	ret += device_create_file(dev, &dev_attr_adr);
+	if (ret) {
+		dev_err(dev, "cannot create attribute\n");
+		return ret;
+	}
+
+	return 0;
+}
+
+static int pinmux_ext_remove(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+
+	device_remove_file(dev, &dev_attr_val);
+	device_remove_file(dev, &dev_attr_adr);
+
+	return 0;
+}
+
+static const struct of_device_id pinmux_ext_dt_ids[] = {
+	{ .compatible = "pinmux-ext" },
+	{},
+};
+MODULE_DEVICE_TABLE(of, pinmux_ext_dt_ids);
+
+static struct platform_driver pinmux_ext_driver = {
+	.driver	= {
+		.name		= "pinmux-ext",
+		.owner		= THIS_MODULE,
+		.of_match_table	= of_match_ptr(pinmux_ext_dt_ids),
+	},
+	.probe	= pinmux_ext_probe,
+	.remove	= pinmux_ext_remove,
+};
+
+//module_platform_driver(pinmux_ext_driver);
+
+static int __init pinmux_ext_init(void)
+{
+	return platform_driver_register(&pinmux_ext_driver);
+}
+
+static void __exit pinmux_ext_exit(void)
+{
+	platform_driver_unregister(&pinmux_ext_driver);
+}
+
+late_initcall(pinmux_ext_init);
+module_exit(pinmux_ext_exit);
diff --git a/drivers/pinctrl/pinmux-ext.h b/drivers/pinctrl/pinmux-ext.h
new file mode 100644
index 0000000..59688e6
--- /dev/null
+++ b/drivers/pinctrl/pinmux-ext.h
@@ -0,0 +1,192 @@
+/*
+ * r8a7790-stout board FPGA definition
+ *
+ * Copyright (C) 2015 Renesas Electronics Europe GmbH
+ * Copyright (C) 2015 Renesas Electronics Corporation
+ * Copyright (C) 2015 Cogent Embedded, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+
+#ifndef _CPLD_H_
+#define _CPLD_H_
+
+/* power-up behaviour */
+#define MODE_MSK_FREE_RUN		0x00000001
+#define MODE_VAL_FREE_RUN		0x00000000
+#define MODE_MSK_STEP_UP		0x00000001
+#define MODE_VAL_STEP_UP		0x00000000
+
+/* boot source */
+#define MODE_MSK_BOOT_SQPI_16KB_FAST	0x0000000E
+#define MODE_VAL_BOOT_SQPI_16KB_FAST	0x00000004
+#define MODE_MSK_BOOT_SQPI_16KB_SLOW	0x0000000E
+#define MODE_VAL_BOOT_SQPI_16KB_SLOW	0x00000008
+#define MODE_MSK_BOOT_SQPI_4KB_SLOW	0x0000000E
+#define MODE_VAL_BOOT_SQPI_4KB_SLOW	0x0000000C
+
+/* booting CPU */
+#define MODE_MSK_BOOT_CA15		0x000000C0
+#define MODE_VAL_BOOT_CA15		0x00000000
+#define MODE_MSK_BOOT_CA7		0x000000C0
+#define MODE_VAL_BOOT_CA7		0x00000040
+#define MODE_MSK_BOOT_SH4		0x000000C0
+#define MODE_VAL_BOOT_SH4		0x000000C0
+
+/* JTAG connection */
+#define MODE_MSK_JTAG_CORESIGHT		0xC0301C00
+#define MODE_VAL_JTAG_CORESIGHT		0x00200000
+#define MODE_MSK_JTAG_SH4		0xC0301C00
+#define MODE_VAL_JTAG_SH4		0x00300000
+
+/* DDR3 (PLL) speed */
+#define MODE_MSK_DDR3_1600		0x00080000
+#define MODE_VAL_DDR3_1600		0x00000000
+#define MODE_MSK_DDR3_1333		0x00080000
+#define MODE_VAL_DDR3_1333		0x00080000
+
+/* ComboPhy0 mode */
+#define MODE_MSK_PHY0_SATA0		0x01000000
+#define MODE_VAL_PHY0_SATA0		0x00000000
+#define MODE_MSK_PHY0_PCIE		0x01000000
+#define MODE_VAL_PHY0_PCIE		0x01000000
+
+/* ComboPhy1 mode */
+#define MODE_MSK_PHY1_SATA1		0x00800000
+#define MODE_VAL_PHY1_SATA1		0x00000000
+#define MODE_MSK_PHY1_USB3		0x00800000
+#define MODE_VAL_PHY1_USB3		0x00800000
+
+/*
+ * Illegal multiplexer combinations.
+ *    MUX                      Conflicts
+ *    name                  with any one of
+ * VIN0_BT656            VIN0_full, SD2
+ * VIN0_full             VIN0_BT656, SD2, AVB, VIN2_(all)
+ * VIN1_BT656            VIN1_(others), SD0
+ * VIN1_10bit            VIN1_(others), SD0, VIN3_with*, I2C1
+ * VIN1_12bit            VIN1_(others), SD0, VIN3_with*, I2C1, SCIFA0_(all)
+ * VIN2_BT656            VIN0_full, VIN2_(others), AVB,
+ * VIN2_withSYNC         VIN0_full, VIN2_(others), AVB, I2C1, SCIFA0_(all),
+ *                       VIN3_with*
+ * VIN2_withFIELD        VIN0_full, VIN2_(others), AVB, SQPI_(all)
+ * VIN2_withSYNCandFIELD VIN0_full, VIN2_(others), AVB, SQPI_(all), I2C1,
+ *                       SCIFA0_(all), VIN3_with*
+ * VIN3_BT656            VIN3_(others), IRQ3
+ * VIN3_withFIELD        VIN3_(others), IRQ3, VIN1_12bit, VIN2_withSYNC,
+ *                       VIN2_withSYNCandFIELD, VIN1_10bit
+ * VIN3_withSYNCandFIELD VIN3_(others), IRQ3, VIN1_12bit, VIN2_withSYNC,
+ *                       VIN2_withSYNCandFIELD, VIN1_10bit, I2C1
+ * AVB                   VIN0_full, VIN2_(all)
+ * QSPI_ONBOARD          VIN2_withFIELD, VIN2_withSYNCandFIELD, QSPI_COMEXPRESS
+ * QSPI_COMEXPRESS       VIN2_withFIELD, VIN2_withSYNCandFIELD, QSPI_ONBOARD
+ * I2C1                  VIN1_12bit, VIN2_withSYNC, VIN2_withSYNCandFIELD,
+ *                       VIN3_withSYNCandFIELD
+ * IRQ3                  VIN3_(all)
+ * SCIFA0_USB            VIN1_12bit, VIN2_withSYNC, VIN2_withSYNCandFIELD,
+ *                       SCIFA0_COMEXPRESS
+ * SCIFA0_COMEXPRESS     VIN1_12bit, VIN2_withSYNC, VIN2_withSYNCandFIELD,
+ *                       SCIFA0_USB
+ * SCIFA2                PWM210
+ * ETH_ONBOARD           ETH_COMEXPRESS
+ * ETH_COMEXPRESS        ETH_ONBOARD
+ * SD0                   VIN1_(all)
+ * SD2                   VIN0_(all)
+ * PWM210                SCIFA2
+ */
+
+/* connected to COM Express connector and CN6 for camera, BT656 only */
+#define MUX_MSK_VIN0_BT656		0x00001001
+#define MUX_VAL_VIN0_BT656		0x00000000
+/* connected to COM Express connector and CN6 for camera, all modes */
+#define MUX_MSK_VIN0_full		0x00001007
+#define MUX_VAL_VIN0_full		0x00000002
+/* connected to COM Express connector, BT656 only */
+#define MUX_MSK_VIN1_BT656		0x00000801
+#define MUX_VAL_VIN1_BT656		0x00000800
+/* connected to COM Express connector, all 10-bit modes */
+#define MUX_MSK_VIN1_10bit		0x00000821
+#define MUX_VAL_VIN1_10bit		0x00000800
+/* connected to COM Express connector, all 12-bit modes */
+#define MUX_MSK_VIN1_12bit		0x000008A1
+#define MUX_VAL_VIN1_12bit		0x00000880
+/* connected to COM Express connector, BT656 only */
+#define MUX_MSK_VIN2_BT656		0x00000007
+#define MUX_VAL_VIN2_BT656		0x00000006
+/* connected to COM Express connector, modes with sync signals */
+#define MUX_MSK_VIN2_withSYNC		0x000000A7
+#define MUX_VAL_VIN2_withSYNC		0x00000086
+/* connected to COM Express connector, modes with field, clken signals */
+#define MUX_MSK_VIN2_withFIELD		0x0000000F
+#define MUX_VAL_VIN2_withFIELD		0x0000000E
+/* connected to COM Express connector, modes with sync, field, clken signals */
+#define MUX_MSK_VIN2_withSYNCandFIELD	0x000000AF
+#define MUX_VAL_VIN2_withSYNCandFIELD	0x0000008E
+/* connected to COM Express connector, BT656 only */
+#define MUX_MSK_VIN3_BT656		0x00000101
+#define MUX_VAL_VIN3_BT656		0x00000100
+/* connected to COM Express connector, modes with field, clken signals */
+#define MUX_MSK_VIN3_withFIELD		0x00000121
+#define MUX_VAL_VIN3_withFIELD		0x00000120
+/* connected to COM Express connector, modes with sync, field, clken signals */
+#define MUX_MSK_VIN3_withSYNCandFIELD	0x00000161
+#define MUX_VAL_VIN3_withSYNCandFIELD	0x00000120
+/* connected to COM Express connector (RGMII) */
+#define MUX_MSK_AVB			0x00000003
+#define MUX_VAL_AVB			0x00000000
+/* connected to on-board QSPI flash */
+#define MUX_MSK_QSPI_ONBOARD		0x00000019
+#define MUX_VAL_QSPI_ONBOARD		0x00000000
+/* connected to COM Express connector */
+#define MUX_MSK_QSPI_COMEXPRESS		0x00000019
+#define MUX_VAL_QSPI_COMEXPRESS		0x00000010
+/* connected to COM Express connector and PMIC */
+#define MUX_MSK_I2C1			0x00000061
+#define MUX_VAL_I2C1			0x00000060
+/* connected to HDMI driver */
+#define MUX_MSK_IRQ3			0x00000101
+#define MUX_VAL_IRQ3			0x00000000
+/* connected to USB/FTDI */
+#define MUX_MSK_SCIFA0_USB		0x00004081
+#define MUX_VAL_SCIFA0_USB		0x00004000
+/* connected to COM Express connector */
+#define MUX_MSK_SCIFA0_COMEXPRESS	0x00004081
+#define MUX_VAL_SCIFA0_COMEXPRESS	0x00000000
+/* connected to COM Express connector */
+#define MUX_MSK_SCIFA2			0x00002001
+#define MUX_VAL_SCIFA2			0x00000000
+/* connected to on-board 10/100 Phy */
+#define MUX_MSK_ETH_ONBOARD		0x00000600
+#define MUX_VAL_ETH_ONBOARD		0x00000000
+/* connected to COM Express connector (RMII) */
+#define MUX_MSK_ETH_COMEXPRESS		0x00000600
+#define MUX_VAL_ETH_COMEXPRESS		0x00000400
+/* connected to on-board MicroSD slot */
+#define MUX_MSK_SD0			0x00000801
+#define MUX_VAL_SD0			0x00000000
+/* connected to COM Express connector */
+#define MUX_MSK_SD2			0x00001001
+#define MUX_VAL_SD2			0x00001000
+/* connected to COM Express connector */
+#define MUX_MSK_PWM210			0x00002001
+#define MUX_VAL_PWM210			0x00002000
+
+#define HDMI_MSK			0x07
+#define HDMI_OFF			0x00
+#define HDMI_ONBOARD			0x07
+#define HDMI_COMEXPRESS			0x05
+#define HDMI_ONBOARD_NODDC		0x03
+#define HDMI_COMEXPRESS_NODDC		0x01
+
+#endif	/* _CPLD_H_ */
-- 
1.9.1

